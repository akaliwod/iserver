import json

from lib import output_helper
from lib.redfish.ucs_rack import endpoint as ucs_rack_endpoint
from lib.redfish.generic import endpoint as generic_endpoint
from lib.redfish.fi import endpoint as fi_endpoint
from lib.redfish.dell import endpoint as dell_endpoint
from lib.redfish.hp import endpoint as hp_endpoint
from lib.redfish import tree


class RedfishEndpoint():
    def __init__(
        self,
        endpoint_type,
        endpoint_ip,
        endpoint_port,
        redfish_username,
        redfish_password,
        ssl_verify=False,
        deep_search_exlusions=True,
        tree_max_execution_time=0,
        verbose=False,
        debug=False
        ):
        self.my_output = output_helper.OutputHelper(
            verbose=verbose,
            debug=debug
        )

        self.endpoint_handler = None

        if endpoint_type == 'generic':
            self.endpoint_handler = generic_endpoint.RedfishEndpointGeneric(
                endpoint_ip,
                endpoint_port,
                redfish_username,
                redfish_password,
                ssl_verify=ssl_verify,
                deep_search_exlusions=deep_search_exlusions,
                verbose=verbose,
                debug=debug
            )
            self.tree_max_execution_time = tree_max_execution_time

        if endpoint_type == 'ucsc':
            self.endpoint_handler = ucs_rack_endpoint.RedfishEndpointUcsRack(
                endpoint_ip,
                endpoint_port,
                redfish_username,
                redfish_password,
                ssl_verify=ssl_verify,
                deep_search_exlusions=deep_search_exlusions,
                verbose=verbose,
                debug=debug
            )
            self.tree_max_execution_time = tree_max_execution_time

        if endpoint_type == 'fi':
            self.endpoint_handler = fi_endpoint.RedfishEndpointFabricInterconnect(
                endpoint_ip,
                endpoint_port,
                redfish_username,
                redfish_password,
                ssl_verify=ssl_verify,
                deep_search_exlusions=deep_search_exlusions,
                verbose=verbose,
                debug=debug
            )
            self.tree_max_execution_time = tree_max_execution_time

        if endpoint_type == 'dell':
            self.endpoint_handler = dell_endpoint.RedfishEndpointDell(
                endpoint_ip,
                endpoint_port,
                redfish_username,
                redfish_password,
                ssl_verify=ssl_verify,
                deep_search_exlusions=deep_search_exlusions,
                verbose=verbose,
                debug=debug
            )
            self.tree_max_execution_time = tree_max_execution_time

        if endpoint_type == 'hp':
            self.endpoint_handler = hp_endpoint.RedfishEndpointHp(
                endpoint_ip,
                endpoint_port,
                redfish_username,
                redfish_password,
                ssl_verify=ssl_verify,
                deep_search_exlusions=deep_search_exlusions,
                verbose=verbose,
                debug=debug
            )
            self.tree_max_execution_time = tree_max_execution_time

        if self.endpoint_handler is None:
            raise ValueError('Unsupported endpoint type: %s' % (endpoint_type))

        self.tree_handler = tree.RedfishTree(self.endpoint_handler)

    def is_connected(self):
        return self.endpoint_handler.is_connected()

    def get_properties(self, path, properties=[]):
        return self.endpoint_handler.get_properties(path, properties=properties)

    def get_tree(self, path):
        self.tree_handler.initialize_tree(
            path,
            True,
            self.tree_max_execution_time
        )
        success = self.tree_handler.get_tree()
        if not success:
            self.my_output.error('Max path walk time reached: %s seconds' % (self.tree_max_execution_time))
            return None

        my_tree = json.loads(
            json.dumps(
                self.tree_handler.tree,
                sort_keys=True
            )
        )

        return my_tree

    def print_tree(self, data, output):
        if data is None:
            return

        if output == 'json':
            self.my_output.default(
                json.dumps(
                    data,
                    indent=4
                )
            )

        if output == 'default':
            self.my_output.default('')
            for uri in data:
                self.my_output.default(uri, underline=True)
                if data[uri] is None:
                    self.my_output.default('No properties')
                    continue

                self.my_output.default(
                    json.dumps(
                        data[uri],
                        indent=4
                    )
                )

                self.my_output.default('')

    def filter_key(self, rules, path=None, data=None):
        if path is None and data is None:
            return None

        if data is None:
            data = self.get_properties(
                path,
                properties=[]
            )
            if data is None:
                return None

        filtered_data = self.endpoint_handler.filter_key(data, rules)
        return filtered_data

    def get_keys(self, path, deep, key_filter):
        keys = {}

        if deep:
            data = self.get_tree(
                path
            )
            if data is None:
                return None

            for uri in data:
                if data[uri] is None:
                    continue

                properties = self.filter_key(
                    key_filter,
                    data=data[uri]
                )

                if len(properties) > 0:
                    keys[uri] = properties

        if not deep:
            path = self.endpoint_handler.path_fixup(path)
            properties = self.filter_key(
                key_filter,
                path=path
            )

            if len(properties) > 0:
                keys[path] = properties

        return keys

    def filter_value(self, rules, path=None, data=None):
        if path is None and data is None:
            return None

        if data is None:
            data = self.get_properties(
                path,
                properties=[]
            )
            if data is None:
                return None

        filtered_data = self.endpoint_handler.filter_value(data, rules)
        return filtered_data

    def get_values(self, path, deep, value_filter):
        values = {}

        if deep:
            data = self.get_tree(
                path
            )
            if data is None:
                return None

            for uri in data:
                if data[uri] is None:
                    continue

                properties = self.filter_value(
                    value_filter,
                    data=data[uri]
                )

                if len(properties) > 0:
                    values[uri] = properties

        if not deep:
            path = self.endpoint_handler.path_fixup(path)
            properties = self.filter_value(
                value_filter,
                path=path
            )

            if len(properties) > 0:
                values[path] = properties

        return values

    def get_children(self, path, deep):
        self.tree_handler.initialize_tree(
            path,
            deep,
            self.tree_max_execution_time
        )
        success = self.tree_handler.get_tree()
        if not success:
            self.my_output.error('Max path walk time reached: %s' % (self.tree_max_execution_time))
            return None

        return sorted(self.tree_handler.tree.keys())

    def print_children(self, path, children, deep, output):
        if output == 'default':
            path = self.endpoint_handler.path_fixup(path)
            self.my_output.default('')
            if deep:
                self.my_output.default('Redfish resource references (recursively): %s' % (path), underline=True)
            else:
                self.my_output.default('Redfish resource references: %s' % (path), underline=True)

            for child in children:
                if child != path:
                    self.my_output.default(child)

        if output == 'json':
            self.my_output.default(json.dumps(children, indent=4))

    def get_descriptions(self, path, deep):
        redfish_properties = [
            '@odata.id',
            '@odata.type',
            '@odata.context',
            'Id',
            'Name',
            'Description'
        ]

        descriptions = {}

        if deep:
            data = self.get_tree(
                path
            )
            if data is None:
                return None

            for uri in data:
                if data[uri] is not None:
                    uri_description = {}
                    for key in redfish_properties:
                        if key in data[uri]:
                            uri_description[key] = data[uri][key]
                    descriptions[uri] = uri_description

        if not deep:
            path = self.endpoint_handler.path_fixup(path)
            properties = self.get_properties(
                path,
                redfish_properties
            )
            if properties is None:
                return None

            descriptions[path] = properties

        return descriptions

    def get_action(self, path, deep):
        key_filter = [
            'eq(Actions)'
        ]

        return self.get_keys(path, deep, key_filter)

    def get_oem(self, path, deep):
        key_filter = [
            'eq(Oem)'
        ]

        return self.get_keys(path, deep, key_filter)
